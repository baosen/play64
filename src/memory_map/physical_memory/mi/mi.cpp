#include <iostream>
#include "mi.hpp"
#include "../../../cpu/cop0/syscon.hpp"
#include "../../../cpu/interpreter/registers/cpu.hpp"
#include "../../../cpu/interpreter/err.hpp"
#include "../../mips_exception_handlers.hpp"
using namespace std;
using namespace System_control;

// R4300 CPU Interrupts:
// Name	        Cause	    Description
// ------------------------------------
// Software 1	CAUSE_SW0	Software generated interrupt 1.
// Software 2	CAUSE_SW1	Software generated interrupt 2.
// RCP	        CAUSE_IP2	RCP interrupt asserted.
// Cartridge	CAUSE_IP3	A peripheral has generated an interrupt.
// Pre-NMI	    CAUSE_IP4	User has pushed reset button on console.
// RDB Read	    CAUSE_IP5	Indy has read the value in the RDB port.
// RDB Write	CAUSE_IP6	Indy has written a value to the RDB port.
// Counter	    CAUSE_IP7	Internal counter has reached its terminal count.

//--------------------------------------------------------------------------
//| 31 - 16 | 15  14  13  12  11  10  | 9   8   | 7 | 6 5 4 3 2      | 1 0 |
//--------------------------------------------------------------------------
//|         | IP7 IP6 IP5 IP4 IP3 IP2 | SW1 SW0 |   | Exception code |     |
//--------------------------------------------------------------------------
// Bit i becomes 1 if an interrupt has occurred at level i and is pending (has not been serviced yet).
// The bits SW1 and SW0 are used for simulated interrupts that can be generated by software only.

#define	CAUSE_BD      0x80000000
#define	CAUSE_CEMASK  0x30000000
#define	CAUSE_CESHIFT 28

#define	CAUSE_SW0 0x100  // Software generated interrupt 1
#define	CAUSE_SW1 0x200  // Software generated interrupt 2.
#define	CAUSE_IP2 0x400  // Hardware generated interrupt 1.
#define	CAUSE_IP3 0x800  // Hardware generated interrupt 2.
#define	CAUSE_IP4 0x1000 // Hardware generated interrupt 3.
#define	CAUSE_IP5 0x2000 // Hardware generated interrupt 4.
#define	CAUSE_IP6 0x4000 // Hardware generated interrupt 5.
#define	CAUSE_IP7 0x8000 // Hardware generated interrupt 6.

#define	CAUSE_IPMASK	0x0000FF00
#define	CAUSE_IPSHIFT	8

#define NOT_CAUSE_EXCMASK	0xFFFFFF83
#define	CAUSE_EXCMASK		0x0000007C

#define	CAUSE_EXCSHIFT	2

namespace {
    // Is interrupts disabled?
    bool disabled() {
        return !(cp0[Status] & 1);
    }
}

// MIPS interface: The bus interface adapter that lies between the CPU and the RDRAM, RSP, RDP and peripherals (RCP).
// The devices use it to interrupt the CPU.
namespace Mi {
    u32 intr = 0, // Read-only interrupt register. A bit is set to 1 when a device interrupts the processor. If not, it is 0.
        // (R): [0] SP intr // Signal Processor interrupt.
        //      [1] SI intr // Serial Interface interrupt.
        //      [2] AI intr // Audio Interface interrupt.
        //      [3] VI intr // Video Interface interrupt.
        //      [4] PI intr // Peripheral Interface DMA interrupt.
        //      [5] DP intr // Display Processor interrupt.
        mask = 0, // Write 1-bit here to ignore interrupts. The interrupt handler won't be called for the interrupts ignored.
        mode = 0;

    static void printmasked() {
        int i = 0;
        auto m = mask;
        while (m) {
            if (!(m & 1))
                goto loop;
            switch (i) {
            case 0:
                cout << "SP masked. ";
                goto loop;
            case 1:
                cout << "SI masked. ";
                goto loop;
            case 2:
                cout << "AI masked. ";
                goto loop;
            case 3:
                cout << "VI masked. ";
                goto loop;
            case 4:
                cout << "PI masked. ";
                goto loop;
            case 5:
                cout << "DP masked. ";
                goto loop;
            default:
                break;
            }
            break;
        loop:
            m >>= 1;
            i++;
        }
        cout << endl;
    }

    // TODO: Messy bugs.
    void interrupt(const uint setbits) 
    {
        cout << "[MI] Current MI status: 0x" << hex << cp0[Status] << endl;

        // Is interrupts disabled?
        if (disabled())
            return;

        // Set the bits that indicates the interrupts thrown.
        intr |= setbits; // bits indicating which peripheral fired the interrupt.

        // Check if RCP caused the interrupt.
        if (intr & ~mask)
            cp0[C0::Cause] |= CAUSE_IP2; // Set bit to indicate that the RCP caused the interrupt.
        else 
            cp0[C0::Cause] &= ~CAUSE_IP2; // Set bit to indicate that RCP did not cause the interrupt.

        //
        // Setup COP0 system control coprocessor for the interrupt.
        //

        // Is exception bit set before?
        if (!(cp0[Status] & 2))
		    cp0[EPC] = Cpu::pc - 4; // Set the address to the instruction that caused the exception. Execution will be returned here.

        // Check if exception occurred in branch delay slot? If true, then set EPC at branch.
		//cp0[Cause] = Cause & ~CAUSE_BD;

        // TODO: ?? (bao: wtf did I do here?)
        cp0[Status] = 2;

        // Set PC to the general exception vector.
        Cpu::pc = GENERAL_EXCEPTION_HANDLER; // MIPS III and onwards uses this address instead of 0x80000080.

        // TODO: Enter kernel mode.
    }

    // Interrupt if there is one pending.
    void intif() {
        // Check if interrupts is disabled.
        if (disabled())
            return;

        // Check if video interrupt has been fired.
        if ((intr & ~8) && (mask & ~8)) {
            // TODO: Draw the framebuffer.
            // Jump to general exception handler.
            Cpu::pc = GENERAL_EXCEPTION_HANDLER;
            throw err("Video interrupt not implemented yet...");
        }
    }

    // Initial mode.
    RD(mode) { 
        return mode;
    }
    WR(mode) {
        mode = val;
        if (mode & 0x800)
            intr |= 0x1f;
    }

    // Interrupt status register.
    // Gets read by the interrupt handler after an interrupt to determine which software or hardware component interrupted the processor.
    RD(intr) { 
        cout << "[MI] Read INTR." << endl;
        return intr; 
    }

    // Interrupt masks.
    // Read the interrupts to ignore:
    RD(intr_mask) {
        cout << "[MI] Read interrupt masks: 0x" << hex << mask << ". ";
        printmasked();
        return mask;
    }
    // Set the interrupts to ignore:
    WR(intr_mask) {
        // Clear and set mask bits.
        mask = (mask & ~((val & 1) | ((val >> 1) & 2) | ((val >> 2) & 4) | ((val >> 3) & 8) | ((val >> 4) & 16) | ((val >> 5) & 32))) // Clear mask bits.
               | ((val >> 1) & 1) | ((val >> 2) & 2) | ((val >> 3) & 4) | ((val >> 4) & 8) | ((val >> 5) & 16) | ((val >> 6) & 32);   // Set mask bits.
        cout << "[MI] Wrote to interrupt masks: 0x" << hex << val << ". ";
        printmasked();
        // TODO: Check interrupt bits and interrupt.
    }

    // Clear SI interrupt bit.
    void clearSI() {
        intr &= ~2;
    }

    // Clear AI interrupt bit.
    void clearAI() {
        intr &= ~4;
    }

    // Clear VI interrupt bit.
    void clearVI() {
        intr &= ~8;
        cout << "[MI] VI interrupt cleared" << endl;
    }

    // Clear PI interrupt bit.
    void clearPI() {
        intr &= ~16;
    }
}
